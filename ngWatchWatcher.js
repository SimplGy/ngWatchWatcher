

angular.module('watchWatcher',[]);


// Usage:
// scopesE   = scopeCounters.byEl();
// scopesS   = scopeCounters.byScope();


angular.module('watchWatcher').factory('scopeCounters', [ '$rootScope', function($rootScope) {

  // Given a scope object, return a count of all the children
  // This only counts immediate children. It is not recursive and does not count grandchildren.
  // If no scope is passed in, it uses $rootScope
  function countChildrenOfScope(scope) {
    scope = scope || $rootScope;
    var count, cur;
    count = 0;
    if (scope.$$childHead) {
      count++;
      cur = scope.$$childHead;
      while (cur.$$nextSibling) {
        count++;
        cur = cur.$$nextSibling;
      }
    }
    return count;
  }

  // Given a DOM element, return an array of scopes on it and children
  // Uses DOM traversal to find children
  // If no element is passed in, it uses the `body` element
  function scopesByEl(element) {
    element = element || angular.element(document.body);
    var scopes;
    scopes = [];
    if (element.data().hasOwnProperty('$scope')) {
      scopes.push(element.data().$scope);
    }
    angular.forEach(element.children(), function(childElement) {
      return scopesByEl($(childElement));
    });
    return scopes;
  }

  // Given a scope, return all scopes on it and it's children.
  // Uses scope traversal to find children.
  function scopesByScope(scope) {
    var q = [ scope || $rootScope ];
    var scopes = [];
    var curScope = null;
    while (q.length > 0) {
      curScope = q.pop();
      if (curScope) {
        scopes.push(curScope);
      }
      if (curScope.$$childHead) {
        q.push(curScope.$$childHead);
      }
      if (curScope.$$nextSibling) {
        q.push(curScope.$$nextSibling);
      }
    }
    return scopes;
  }

  // Publicize
  return api = {
    countChildren: countChildrenOfScope,
    byEl: scopesByEl,
    byScope: scopesByScope
  };
}]);
// Generated by CoffeeScript 1.7.1
(function() {
  describe('scopeCounters.factory', function() {
    var $rootScope, childScope, el, scope, scopeCounters;
    scope = void 0;
    scopeCounters = void 0;
    $rootScope = void 0;
    childScope = void 0;
    el = void 0;
    beforeEach(function() {
      angular.mock.module('watchWatcher');
      return angular.mock.inject(function(_scopeCounters_, _$rootScope_, $compile) {
        scopeCounters = _scopeCounters_;
        $rootScope = _$rootScope_;
        $rootScope.$new();
        childScope = $rootScope.$new();
        childScope.$new();
        childScope.$new();
        childScope.$new();
        childScope.testVal = 'Scope is working';
        el = $compile('<div>{{testVal}}</div>')(childScope);
        return $rootScope.$digest();
      });
    });
    it('is defined', function() {
      return expect(scopeCounters).toBeDefined();
    });
    describe('test scope preparation', function() {
      it('$rootScope is available and looks like an angular scope', function() {
        expect($rootScope).toBeDefined();
        return expect(typeof $rootScope.$new).toBe('function');
      });
      return it('$rootScope has other scopes in it', function() {
        expect($rootScope.$$childHead).toBeDefined();
        return expect($rootScope.$$childHead.$$nextSibling).toBeDefined();
      });
    });
    describe('.countChildren(scope)', function() {
      it('is a function', function() {
        return expect(typeof scopeCounters.countChildren).toBe('function');
      });
      it('gets correct counts of immediate children', function() {
        expect(scopeCounters.countChildren($rootScope)).toBe(2);
        expect(scopeCounters.countChildren(childScope)).toBe(3);
        childScope.$new();
        return expect(scopeCounters.countChildren(childScope)).toBe(4);
      });
      return it("detects isolate scope", function() {
        expect(scopeCounters.countChildren(childScope)).toBe(3);
        childScope.$new(true);
        return expect(scopeCounters.countChildren(childScope)).toBe(4);
      });
    });
    describe('.byScope()', function() {
      it('is a function', function() {
        return expect(typeof scopeCounters.byScope).toBe('function');
      });
      it('finds the right number of scopes', function() {
        return expect(scopeCounters.byScope().length).toBe(6);
      });
      return it('detects the results of destorying scope', function() {
        expect(scopeCounters.byScope().length).toBe(6);
        childScope.$$childHead.$destroy();
        expect(scopeCounters.byScope().length).toBe(5);
        childScope.$destroy();
        return expect(scopeCounters.byScope().length).toBe(2);
      });
    });
    return describe('byEl', function() {
      it('is a function', function() {
        return expect(typeof scopeCounters.byEl).toBeDefined();
      });
      it('has an element to test against', function() {
        return expect(el.html()).toBe('Scope is working');
      });
      return it('Finds scopes by element', function() {
        return expect(scopeCounters.byEl(el).length).toBe(1);
      });
    });
  });

}).call(this);


// Usage:
// watchersE = watchCounters.byEl();
// watchersS = watchCounters.byScope();


angular.module('watchWatcher').factory('watchCounters', [ '$rootScope', function($rootScope) {

  // Given a DOM element, return an array of watchers on it and children
  // Uses DOM traversal to find children.
  // If no element is passed in, it uses the `body` element
  function watchersByEl(element) {
    element = element || angular.element(document.body);
    var watchers;
    watchers = [];
    if (element.data().hasOwnProperty('$scope')) {
      watchers = watchers.concat(element.data().$scope.$$watchers);
    }
    angular.forEach(element.children(), function(childElement) {
      return watchersByEl($(childElement));
    });
    return watchers;
  }

  // Given a scope, return all watchers on it and it's children.
  // Uses scope traversal to find children.
  function watchersByScope(scope) {
    var q = [ scope || $rootScope ];
    var watchers = [];
    var curScope = null;
    while (q.length > 0) {
      curScope = q.pop();
      if (curScope.$$watchers) {
        watchers = watchers.concat(curScope.$$watchers);
      }
      if (curScope.$$childHead) {
        q.push(curScope.$$childHead);
      }
      if (curScope.$$nextSibling) {
        q.push(curScope.$$nextSibling);
      }
    }
    return watchers;
  }

  // Publicize
  return api = {
    byEl: watchersByEl,
    byScope: watchersByScope
  };
}]);
// Generated by CoffeeScript 1.7.1
(function() {
  describe('watchCounters.factory', function() {
    var $rootScope, childScope, el, scope, watchCounters;
    scope = void 0;
    watchCounters = void 0;
    $rootScope = void 0;
    childScope = void 0;
    el = void 0;
    beforeEach(function() {
      angular.mock.module('watchWatcher');
      return angular.mock.inject(function(_watchCounters_, _$rootScope_, $compile) {
        watchCounters = _watchCounters_;
        $rootScope = _$rootScope_;
        $rootScope.$new();
        childScope = $rootScope.$new();
        childScope.$new();
        childScope.$new();
        $rootScope.$watch(function() {});
        $rootScope.$watch(function() {});
        childScope.testVal = 'Scope is working';
        el = $compile('<div ng-class="{ hasVal: testVal }">{{testVal}}</div>')(childScope);
        return $rootScope.$digest();
      });
    });
    it('is defined', function() {
      return expect(watchCounters).toBeDefined();
    });
    describe('test scope preparation', function() {
      it('$rootScope is available and looks like an angular scope', function() {
        expect($rootScope).toBeDefined();
        return expect(typeof $rootScope.$new).toBe('function');
      });
      return it('$rootScope has other scopes in it', function() {
        expect($rootScope.$$childHead).toBeDefined();
        return expect($rootScope.$$childHead.$$nextSibling).toBeDefined();
      });
    });
    describe('.byScope()', function() {
      it('counts the correct number of watches on a scope', function() {
        return expect(watchCounters.byScope(childScope).length).toBe(2);
      });
      return it('counts watches on the scope and all it\'s children', function() {
        return expect(watchCounters.byScope($rootScope).length).toBe(4);
      });
    });
    return describe('.byEl()', function() {
      return it('counts by element correctly', function() {
        return expect(watchCounters.byEl(el).length).toBe(2);
      });
    });
  });

}).call(this);


angular.module('watchWatcher').controller('WatchLightController',   function() {

//  var startTime = Date.now();
  var cleanUpFrequency = 5000; // how often to clean up the stored information
  var digestsToKeep = 50; // How many recent digests to store
  var watchCount = 0;
  var recentDigests = [];

  // Track that a watch happened
  function countWatch() {
    watchCount++;
    var curDigest = { start: Date.now() };
    recentDigests.push(curDigest);
    setTimeout(function(){
      curDigest.end = Date.now();
      curDigest.duration = curDigest.end - curDigest.start;
    },0); // measure the compute time of the digest loop by assuming it's blocking
  }

  // Given an array of digest, how many digests were there per second, on average?
  function getDigestsPerSecond(digests) {
    digests = digests || recentDigests;
    var count = digests.length;
    var time = digests[count - 1].start - digests[0].start;
    time /= 1000;
    return Math.round(count / time * 10) / 10;
  }

  // Given an array of digests, what was the average duration?
  function getAverageDigestDuration(digests) {
    digests = digests || recentDigests;
    var i, len, duration, sum = 0;
    for (i=0,len=digests.length; i<len; i++){
      duration = digests[i].duration
      if (duration) { // avoid any NaNs that may have shown up, 0s (falsy) are safe to ignore
        sum += duration;
      }
    }
    return Math.round(sum / len * 10) / 10;
  }

  function logInformation(){
    console.log(
      '\n' +
        'Digest Information\n' +
        '------------------\n' +
        'Digests Per Second:      ' + getDigestsPerSecond(recentDigests)      + ' digests   (fewer is less taxing)\n' +
        'Average Digest Duration: ' + getAverageDigestDuration(recentDigests) + ' ms        (shorter is more performant)\n' +
//          'Recent Digest Count:     ' + recentDigests.length + '\n' +
        'Watches Fired So Far:    ' + watchCount + '\n' +
        '\n',
      { digests: recentDigests }
    );
  }

  setInterval(cleanUp, cleanUpFrequency);
  function cleanUp() {
    // Trim the recent digests to last 100 so they don't get huge
    if (recentDigests.length > digestsToKeep) {
      recentDigests = recentDigests.slice( - digestsToKeep);
    }
  }

  // Publicize
  this.cleanUp = cleanUp;
  this.countWatch = countWatch;
  this.logInformation = logInformation;
  this.getDigestsPerSecond = getDigestsPerSecond;
  this.getAverageDigestDuration = getAverageDigestDuration;
  this.getRecentDigests = function(){ return recentDigests };

});
// Generated by CoffeeScript 1.7.1
(function() {
  describe('watchLight.controller', function() {
    var controller, sleep;
    controller = void 0;
    sleep = function(amount) {
      var startTime, _results;
      amount = amount || 10;
      startTime = Date.now();
      _results = [];
      while (Date.now() - startTime < amount) {
        _results.push(startTime);
      }
      return _results;
    };
    beforeEach(function() {
      angular.mock.module('watchWatcher');
      return angular.mock.inject(function($controller) {
        return controller = $controller('WatchLightController');
      });
    });
    describe('.countWatch()', function() {
      it('Adds measurements', function() {
        expect(controller.getRecentDigests().length).toBe(0);
        controller.countWatch();
        controller.countWatch();
        controller.countWatch();
        return expect(controller.getRecentDigests().length).toBe(3);
      });
      return it('measures duration', function() {
        var lastDigest;
        expect(controller.getRecentDigests().length).toBe(0);
        controller.countWatch();
        sleep(10);
        lastDigest = controller.getRecentDigests()[0];
        expect(lastDigest).toBeDefined();
        waits(20);
        return runs(function() {
          var _ref;
          return expect((10 <= (_ref = lastDigest.duration) && _ref < 15)).toBe(true);
        });
      });
    });
    describe('.getDigestsPerSecond()', function() {
      return it('averages out digests over time', function() {
        var i, _i;
        expect(controller.getRecentDigests().length).toBe(0);
        for (i = _i = 1; _i <= 5; i = ++_i) {
          controller.countWatch();
        }
        waits(1000 / 10);
        return runs(function() {
          var _j, _ref;
          for (i = _j = 1; _j <= 5; i = ++_j) {
            controller.countWatch();
          }
          expect(controller.getRecentDigests().length).toBe(10);
          return expect((95 < (_ref = controller.getDigestsPerSecond()) && _ref < 105)).toBe(true);
        });
      });
    });
    return describe('.getAverageDigestDuration()', function() {
      it('gets the average duration of one digest', function() {
        expect(controller.getRecentDigests().length).toBe(0);
        controller.countWatch();
        sleep(50);
        waits(0);
        return runs(function() {
          var _ref;
          expect(controller.getRecentDigests().length).toBe(1);
          return expect((45 < (_ref = controller.getAverageDigestDuration()) && _ref < 55)).toBe(true);
        });
      });
      return it('gets the average duration of many digests', function() {
        expect(controller.getRecentDigests().length).toBe(0);
        waits(0);
        runs(function() {
          controller.countWatch();
          return sleep(10);
        });
        waits(0);
        runs(function() {
          controller.countWatch();
          return sleep(100);
        });
        waits(0);
        return runs(function() {
          var avg, fast, slow;
          expect(controller.getRecentDigests().length).toBe(2);
          fast = controller.getRecentDigests()[0].duration;
          slow = controller.getRecentDigests()[1].duration;
          avg = controller.getAverageDigestDuration();
          console.log("fast: " + fast + ". slow: " + slow + ", avg: " + avg);
          expect((5 < fast && fast < 15)).toBe(true);
          expect((95 < slow && slow < 120)).toBe(true);
          return expect(Math.round(avg)).toBe(Math.round((fast + slow) / 2));
        });
      });
    });
  });

}).call(this);



angular.module('watchWatcher').directive('watchLight', [ '$rootScope', function($rootScope){
  return {
    restrict: 'E',
    template: '<i class="watchLight"\n   title="Blinking indicates $digest loop activity.\nClick to log details."\n   style="cursor: pointer;\n   display: block; position: fixed;\n   top: 10px; right: 10px;\n   width:14px; height:14px;\n   border-radius: 50%; background-color: #ddd;\n   -webkit-transition:background-color .15s, box-shadow .04s;\n   transition:background-color .15s, box-shadow .04s;\n"></i>',
    replace: true,
    controller: 'WatchLightController',
    link: function(scope, el, attrs, controller){

      var turnOffLighter, turnOffShimmer;

      // Light up the bulb, and set timeouts to un-light it after a bit
      function doLightUp(color, shimmerColor) {
        color = color || '#5AB953';
        shimmerColor = shimmerColor || '#29832B';
        el.css('background-color', color);
        el.css('box-shadow', 'inset 0 0 0 2px ' + shimmerColor);
        clearTimeout(turnOffLighter);
        clearTimeout(turnOffShimmer);
        turnOffLighter = setTimeout(unLighter, 700);
        turnOffShimmer = setTimeout(unShimmer, 100);
      }
      function unLighter() { el.css('background-color', '#ddd'); } // The light effect is slow and stays for a while, giving you a sense of general activity.
      function unShimmer() { el.css('box-shadow', 'inset 0 0 0 0 #49A34B'); } // The shimmer effect is quick and leaves quickly, giving you a sense for rapid activity

      // On click, show something useful
      el.on('click', function(){
        doLightUp('#69d', '#369');
        controller.cleanUp();
        controller.logInformation();
      });



      function onRootScopeWatch() {
        controller.countWatch();
        doLightUp();
        return false; // Always return the same thing, so we don't trigger a watch change.
      }

      // Set this up on $rootScope, since we don't want DOM placement to determine which scope we're monitoring.
      $rootScope.$watch(onRootScopeWatch);
    }
  }
}]);